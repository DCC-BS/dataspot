### This is entirely generated by Claude 3.7-sonnet. ###

import json
import unittest
from unittest.mock import patch, MagicMock, call

import pytest
from requests import HTTPError

from src.dataspot_client import DataspotClient
from src.dataspot_dataset import Dataset


class TestDataspotClient(unittest.TestCase):
    """Test class for DataspotClient methods."""

    def setUp(self):
        """Set up test fixtures before each test."""
        # Create a patcher for the DataspotAuth class
        self.auth_patcher = patch('src.dataspot_client.DataspotAuth')
        self.mock_auth = self.auth_patcher.start()
        # Mock the headers returned by the auth
        self.mock_auth.return_value.get_headers.return_value = {'Authorization': 'Bearer fake-token'}
        
        # Mock environment variables
        self.env_patcher = patch('src.dataspot_client.os.getenv')
        self.mock_getenv = self.env_patcher.start()
        self.mock_getenv.return_value = 'https://test-dataspot-api.com'
        
        # Create the client
        self.client = DataspotClient()
        self.client.base_url = 'https://test-dataspot-api.com'
        self.client.database_name = 'test-db'
        self.client.dnk_scheme_name = 'Test-DNK'
        self.client.tdm_scheme_name = 'Test-TDM/collections/Test-Models'
        
        # Mock find_dataset_path and find_tdm_dataobject_path methods
        self.client.find_dataset_path = MagicMock(return_value='rest/test-db/datasets/test-dataset')
        self.client.find_tdm_dataobject_path = MagicMock(return_value='rest/test-db/schemes/Test-TDM/assets/test-dataset')
        
        # Sample dataset for testing
        self.sample_dataset = self._create_sample_dataset()
        
    def tearDown(self):
        """Tear down test fixtures after each test."""
        self.auth_patcher.stop()
        self.env_patcher.stop()
    
    def _create_sample_dataset(self):
        """Create a sample dataset for testing."""
        dataset = MagicMock(spec=Dataset)
        dataset.name = 'test-dataset'
        dataset.get_departement_dienststelle_sammlung_subsammlung.return_value = (
            'TestDept', 'TestDiv', 'TestColl', None
        )
        dataset.to_json.return_value = {
            '_type': 'TestDataset',
            'label': 'test-dataset',
            'title': 'Test Dataset',
            'description': 'Test dataset for unit testing'
        }
        return dataset
    
    def _mock_response(self, status_code=200, json_data=None, raise_for_status=None):
        """Create a mock response object for mocking requests."""
        mock_resp = MagicMock()
        mock_resp.status_code = status_code
        mock_resp.raise_for_status = MagicMock()
        
        if raise_for_status:
            mock_resp.raise_for_status.side_effect = raise_for_status
            
        if json_data:
            mock_json = MagicMock()
            mock_json.return_value = json_data
            mock_resp.json = mock_json
            
        return mock_resp
    
    def _setup_parent_collection_mock(self, requests_get_mock):
        """Setup mocks for parent collection resolution."""
        # Mock parent collection retrieval
        parent_collection_response = self._mock_response(
            json_data={
                'id': 'test-collection-uuid',
                '_links': {'self': {'href': '/rest/collections/test-collection-uuid'}}
            }
        )
        
        # Configure the mock to return 'test-collection-uuid' for the get('id') call
        parent_collection_response.json.return_value = {'id': 'test-collection-uuid'}
        
        requests_get_mock.return_value = parent_collection_response
        return parent_collection_response

    def _setup_dataset_exists_mock(self, requests_get_mock, exists=True):
        """Setup mocks for dataset existence check."""
        # Create parent collection response
        parent_collection_response = self._mock_response(
            json_data={
                'id': 'test-collection-uuid',
                '_links': {'self': {'href': '/rest/collections/test-collection-uuid'}}
            }
        )
        parent_collection_response.json.return_value = {'id': 'test-collection-uuid'}
        
        if exists:
            # Dataset exists response
            dataset_response = self._mock_response(
                json_data={
                    'id': 'test-dataset-uuid',
                    '_links': {'self': {'href': '/rest/collections/test-collection-uuid/assets/test-dataset'}}
                }
            )
            # Set up side effect for multiple calls
            requests_get_mock.side_effect = [parent_collection_response, dataset_response]
        else:
            # Dataset doesn't exist (404)
            error = HTTPError()
            error.response = MagicMock()
            error.response.status_code = 404
            
            # Set up side effect for multiple calls
            requests_get_mock.side_effect = [
                parent_collection_response,
                error,
                parent_collection_response  # For retry after creating hierarchy
            ]
        
        return requests_get_mock

    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    @patch('os.path.exists')
    def test_ensure_ods_imports_collection_cache_hit(self, mock_exists, mock_post, mock_get):
        """Test ensure_ods_imports_collection when the UUID is correctly retrieved from cache."""
        # Setup the UUID cache with a valid entry
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = "test-collection-uuid"
        
        # Setup the mock response for validating the UUID
        mock_response = self._mock_response(json_data={"id": "test-collection-uuid", "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}})
        mock_get.return_value = mock_response
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        self.client.uuid_cache.get_uuid.assert_called_once_with('Collection', 'ODS-Imports')
        mock_get.assert_called_once()  # Should only call to validate the UUID
        mock_post.assert_not_called()  # Should not create a new collection
    
    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    def test_ensure_ods_imports_collection_cache_miss_collection_exists(self, mock_post, mock_get):
        """Test ensure_ods_imports_collection when cache misses but collection exists."""
        # Setup the UUID cache with a miss
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = None
        
        # Setup mock responses - DNK scheme exists and ODS-Imports collection exists
        dnk_scheme_response = self._mock_response(json_data={"id": "test-scheme-uuid"})
        ods_collection_response = self._mock_response(json_data={
            "id": "test-collection-uuid",
            "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}
        })
        mock_get.side_effect = [dnk_scheme_response, ods_collection_response]
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        self.client.uuid_cache.get_uuid.assert_called_once_with('Collection', 'ODS-Imports')
        self.client.uuid_cache.add_or_update_asset.assert_called_once()  # Should update cache
        self.assertEqual(mock_get.call_count, 2)  # Should check scheme and collection
        mock_post.assert_not_called()  # Should not create anything
    
    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    def test_ensure_ods_imports_collection_create_collection(self, mock_post, mock_get):
        """Test ensure_ods_imports_collection when collection doesn't exist and needs to be created."""
        # Setup the UUID cache with a miss
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = None
        
        # Setup mock responses - DNK scheme exists but ODS-Imports collection doesn't
        dnk_scheme_response = self._mock_response(json_data={"id": "test-scheme-uuid"})
        # Collection not found response (404)
        collection_error = HTTPError()
        collection_error.response = MagicMock()
        collection_error.response.status_code = 404
        
        # Create collection response
        collection_created_response = self._mock_response(json_data={
            "id": "test-collection-uuid",
            "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}
        })
        
        mock_get.side_effect = [dnk_scheme_response, collection_error]
        mock_post.return_value = collection_created_response
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        mock_post.assert_called_once()  # Should create collection
        self.client.uuid_cache.add_or_update_asset.assert_called_once()  # Should update cache
    
    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    def test_ensure_ods_imports_collection_create_scheme_and_collection(self, mock_post, mock_get):
        """Test ensure_ods_imports_collection when both scheme and collection need to be created."""
        # Setup the UUID cache with a miss
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = None
        
        # Setup mock responses
        # Scheme not found response (404)
        scheme_error = HTTPError()
        scheme_error.response = MagicMock()
        scheme_error.response.status_code = 404
        
        # Collection not found error (for when checking if collection exists)
        collection_error = HTTPError()
        collection_error.response = MagicMock()
        collection_error.response.status_code = 404
        
        # Scheme creation response
        scheme_created_response = self._mock_response(json_data={
            "id": "test-scheme-uuid",
            "_links": {"self": {"href": "/rest/test-db/schemes/test-scheme-uuid"}}
        })
        
        # Collection creation response
        collection_created_response = self._mock_response(json_data={
            "id": "test-collection-uuid",
            "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}
        })
        
        # Set up side effects: First scheme doesn't exist, then collection check should be skipped
        mock_get.side_effect = [scheme_error, collection_error]
        mock_post.side_effect = [scheme_created_response, collection_created_response]
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        self.assertEqual(mock_post.call_count, 2)  # Should create both scheme and collection
        self.client.uuid_cache.add_or_update_asset.assert_called_once()  # Should update cache
    
    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    @patch('tempfile.NamedTemporaryFile')
    @patch('os.path.exists')
    @patch('os.path.isfile')
    @patch('os.remove')
    @patch('shutil.copy2')
    def test_ensure_ods_imports_collection_csv_deleted(self, mock_copy, mock_remove, mock_isfile, 
                                                     mock_exists, mock_tempfile, mock_post, mock_get):
        """Test ensure_ods_imports_collection when the CSV file is deleted after being written."""
        # Mock the actual file operations to avoid file system issues
        mock_exists.return_value = True
        mock_isfile.return_value = True
        mock_tempfile.return_value.name = "mock_temp_file.csv"
        
        # Setup the client with a mocked UUID cache instead of a real one
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = "test-collection-uuid"
        
        # When we try to verify the cached UUID, return a 404
        http_error = HTTPError("Not found")
        http_error.response = MagicMock()
        http_error.response.status_code = 404
        
        # Setup mock responses for when cache validation fails
        dnk_scheme_response = self._mock_response(json_data={
            "id": "test-scheme-uuid",
            "_links": {"self": {"href": "/rest/test-db/schemes/Datennutzungskatalog"}}
        })
        
        ods_collection_response = self._mock_response(json_data={
            "id": "test-collection-uuid",
            "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}
        })
        
        # Set up side effects correctly
        mock_get.side_effect = [http_error, dnk_scheme_response, ods_collection_response]
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        self.assertEqual(mock_get.call_count, 3)  # Should try cache validation, check scheme, check collection
        
        # Update assertion for correct functionality
        # The collection UUID is returned, not the scheme UUID
        self.client.uuid_cache.add_or_update_asset.assert_called_with(
            'Collection', 'ODS-Imports', 'test-collection-uuid', 
            ods_collection_response.json()['_links']['self']['href']
        )
    
    @patch('src.dataspot_client.requests_get')
    @patch('src.dataspot_client.requests_post')
    def test_ensure_ods_imports_collection_renamed_asset(self, mock_post, mock_get):
        """Test ensure_ods_imports_collection when an asset has been renamed in Dataspot."""
        # Setup the UUID cache with an old name
        self.client.uuid_cache = MagicMock()
        self.client.uuid_cache.get_uuid.return_value = "test-collection-uuid"
        
        # When verifying the cached UUID, return valid data but with an updated name
        renamed_collection_response = self._mock_response(json_data={
            "id": "test-collection-uuid",
            "label": "ODS-Imports-Renamed",  # Name changed in Dataspot
            "_links": {"self": {"href": "/rest/test-db/collections/test-collection-uuid"}}
        })
        
        mock_get.return_value = renamed_collection_response
        
        # Call the method
        result = self.client.ensure_ods_imports_collection()
        
        # Verify results
        self.assertEqual(result, "test-collection-uuid")
        
        # It should not update the cache with the new name since this is specifically looking for "ODS-Imports"
        # In a real scenario, this would lead to a cache miss on next call with the new name
        self.client.uuid_cache.add_or_update_asset.assert_not_called()


if __name__ == '__main__':
    pytest.main() 